[ { "title": "链表归纳（更新中）", "url": "/posts/Linked-List/", "categories": "学习笔记", "tags": "Python, Algorithm", "date": "2022-05-27 18:38:00 -0500", "snippet": "链表类型 单向链表 双向链表 循环链表1. 单向链表单向链表的每个节点由val和next两部分组成，分别代表了该节点储存的值以及指向下一个节点的指针。 链表的开始节点（入口节点）被称为head。class ListNode: def __init__(self, val=0, next=None): self.val = val self.next =...", "content": "链表类型 单向链表 双向链表 循环链表1. 单向链表单向链表的每个节点由val和next两部分组成，分别代表了该节点储存的值以及指向下一个节点的指针。 链表的开始节点（入口节点）被称为head。class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next特点 只有指向下一个节点的指针，只能单向移动查询 便于理解，只需要考虑一个指针走向2. 双向链表双向链表的每个节点由val，prev和next三部分组成，分别代表了该节点储存的值，指向前一个节点的指针以及指向下一个节点的指针。class ListNode: def __init__(self, val): self.val = val self.prev = None self.next = None特点 每个节点都可以查询到它的前一个节点或者后一个节点，双向查询 在改变链表的时候需要考虑两个指针的指向改变，比单链表复杂3. 循环链表循环链表可以是单向链表也可以是双向链表，特点是首尾相连， 可以解决约瑟夫环等问题。链表存储方式链表在内存中不是连续分布的，通过指针来连接内存中存储的各个节点。逻辑上相邻的数据元素在物理地址上可能相邻，也可能不相邻。其在物理地址上的表现是随机的。链表优缺点优点 存储空间不必事先分配，在需要存储空间的时候可以临时申请，不会造成空间的浪费 一些操作的时间效率远比数组高（插入、移动、删除元素等）缺点 不仅数据元素本身的数据信息要占用存储空间，指针也需要占用存储空间，链表结构比数组结构的空间开销大。链表基本操作1. 创建一个线性链表需要先创建一个头节点head，然后后续为新添加的数据创建新节点并从尾部插入，最后返回的是链表头节点的地址来表示整个链表。需要一个指针跟踪尾部节点来插入新节点。 时间复杂度为O(n)，n为链表长度。head = ListNode(0)curr = headfor i in range(len(data)): node = ListNode(data[i]) curr.next = node curr = curr.next2. 求线性链表长度需要一个指针从头节点head出发，遍历每一个节点，每经过一个count加一，直到有节点next指向的值为None（到达链表尾部）， count的值就为链表长度。 时间复杂度为O(n)，n为链表长度。count = 0curr = headwhile curr: count += 1 curr = curr.next return count3. 查找元素不像数组，链表的元素查找必须从头节点出发，使用一个指针遍历元素，如果发现val符合条件的就返回指针所在节点的地址，相反就返回None。 时间复杂度为O(n)，n为链表长度。count = 0curr = headwhile curr: if val == curr.val: return curr curr = curr.nextreturn None4. 插入元素链表的插入操作分为三种： 在链表头部插入新节点 在链表尾部插入新节点 在链表第i处插入新节点头部插入: O(1)直接以目标元素值创建一个节点，将其next指针指向原链表的head头节点，并把这个新节点指向为新的头节点head。因为在链表头部插入链节点与链表的长度无关，所以该算法的时间复杂度为O(1)。node = ListNode(val)node.next = headhead = node尾部插入: O(n)以目标元素值创建一个节点，用一个指针curr从头节点出发，遍历直到到达尾部节点，将指针curr.next指向创造的新节点。很明显，curr指针需要走整个链表才能到达尾部，时间复杂度为O(n)。node = ListNode(val)curr = headwhile curr.next: curr = curr.nextcurr.next = node中间插入: 平均O(n)以目标元素值创建一个节点，用一个指针curr以及一个计数器count从头节点出发，遍历直到count = i - 1停止遍历，将新节点的next指针指向原本的curr.next节点，并将指针curr.next指向创造的新节点。因为将cur从链表头部移动到第i个链节点之前的操作平均时间复杂度是O(n)，所以该算法的时间复杂度是O(n)。node = ListNode(val)count = 0curr = headwhile curr and count &lt; index - 1: count += 1 curr = curr.next if not curr: return 'Error' node.next = curr.nextcurr.next = node" }, { "title": "双指针、滑动窗口归纳（更新中）", "url": "/posts/Two-Pointers/", "categories": "学习笔记", "tags": "Python, Algorithm", "date": "2022-05-20 01:37:00 -0500", "snippet": "形式 对撞指针 快慢指针 分离指针1. 对撞指针对撞指针是指left, right两个指针，分别指向数组第一个和最后一个元素。在loop里面满足条件时，left指针递增或者是right指针递减，直到两个指针指向同一个元素或者是满足题目的条件结束循环。left, right = 0, len(nums) - 1while left &lt; right:\tif condition1:\t\t...", "content": "形式 对撞指针 快慢指针 分离指针1. 对撞指针对撞指针是指left, right两个指针，分别指向数组第一个和最后一个元素。在loop里面满足条件时，left指针递增或者是right指针递减，直到两个指针指向同一个元素或者是满足题目的条件结束循环。left, right = 0, len(nums) - 1while left &lt; right:\tif condition1:\t\treturn something\telif condition2:\t\tleft += 1\telse:\t\tright -= 1return something_else应用 有序数组查找类问题：二分查找，两数之和等等 字符串反转类问题：回文字符串等等2. 快慢指针快慢指针是指slow, fast两个指针，分别指向数组第一个和第二个元素（也有可能都从第一个元素开始）。在loop里面满足一定条件时，slow指针增加，满足其他一定条件时（或者不需要条件），fast指针增加，直到fast指针指向数组最后一个元素或者是满足题目的条件结束循环。slow, fast = 0, 1while fast &lt; len(nums):\tif condition1:\t\tslow += 1 # 切记切记快慢指针都是加法！！总是写成减法\tfast += 1return something应用 数组的添加、删除元素，要求不使用额外空间 链表中的判断是否有环、长度问题滑动窗口 来自滑动窗口协议（Sliding Window Protocol)，这是一个data link layer协议，TCP也有用到，Receiver发送window size到Sender来控制发送速度，Sender允许发送多个packets而不用等待ACK信号。这个协议提高了数据传输的效率和throughput。 属于快慢指针的一种特殊形式。应用范围和分类 一般用于需要查找连续一段区间的subset/substring问题，可以简化传统的nested double loop来提高效率 分为两种形态： 固定长度窗口 非固定长度窗口：最大/最小长度 I. 固定长度窗口 窗口长度给定，判断当窗口长度达到给定size时移动窗口1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold 大小为K且平均值大于等于阈值的子数组数目class Solution: def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -&gt; int: slow, fast = 0, 0\t# 按照快慢指针初始化两个指针 window_sum = 0\t\t# 初始化一个窗口，这里是subarray的和 res = 0\t\t# 初始化最终的结果 while fast &lt; len(arr): window_sum += arr[fast]\t\t# 把新元素放到窗口里面 if fast - slow + 1 &gt;= k:\t# 当窗口大小超过了给定大小，需要缩减以维持窗口长度 if window_sum / k &gt;= threshold:\t\t# 这边是判断是否满足题目条件，满足的话记录结果 res += 1 window_sum -= arr[slow]\t\t# 移除窗口左侧元素，并且增加slow指针来维持size slow += 1 fast += 1\t\t# 快指针一直往右移动 return resII. 非固定长度窗口 一般要找最小或者最大窗口长度的满足条件的subarray 首先需要增加fast指针以扩大窗口，当窗口内元素满足条件后暂停扩张 然后需要减少slow指针以缩小窗口，移除窗口左侧元素，直到窗口内元素不再满足条件。 结构为两层while loop3. Longest Substring Without Repeating Characters 无重复字符的最长子串class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: slow, fast = 0, 0 substring = dict()\t\t# 初始化一个窗口，这里使用链表（词典） res = 0 while fast &lt; len(s): \t# 把新元素放进窗口，这边是由于dict特性需要写一个判断 if s[fast] not in substring: substring[s[fast]] = 1 else: substring[s[fast]] += 1 while substring[s[fast]] &gt; 1:\t# 切记这边的判断是while，因为每次缩减窗口之后都要进行判断。这边的判断是是否重复元素 \t# 移除窗口左侧元素并缩小size substring[s[slow]] -= 1 slow += 1 res = max(fast - slow + 1, res)\t\t# 每次都要留下最大值，fast-slow+1 指的是窗口size，也就是substring长度 fast += 1 return res209. Minimum Size Subarray Sum 元素和大于给定值的长度最小的子数组class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int: slow, fast = 0, 0 window_sum = 0 res = len(nums) + 1 \t# 求最小值，所以初始化为大值 while fast &lt; len(nums): window_sum += nums[fast]\t# 添加新元素 while window_sum &gt;= target: res = min(res, fast - slow + 1)\t\t# 注意这边最终结果要的是最小值，需要放进去实时更新 window_sum -= nums[slow] slow += 1 fast += 1 if res == len(nums) + 1: return 0 return res 713. Subarray Product Less Than K 乘积小于K的子数组class Solution: def numSubarrayProductLessThanK(self, nums: List[int], k: int) -&gt; int: if k &lt;= 1: return 0 slow, fast = 0, 0 res = 0 window_mult = 1 while fast &lt; len(nums): window_mult *= nums[fast] while window_mult &gt;= k: window_mult /= nums[slow] slow += 1 # 下面这一行非常关键！！如果当前乘积小于k，那么right左边含right的所有子串乘积一定都小于k，这个数量刚好就是窗口长度 res += (fast - slow + 1) fast += 1 return res3. 分离指针分离指针是指p1, p2两个指针，分别指向不同数组/链表的第一个元素。在loop里面满足一定条件时，两个指针同时右移，满足另外一些条件时只右移p1指针，满足另一些条件时只右移p2指针，直到其中一个数组/链表遍历完成或者是满足题目的条件结束循环。p1, p2 = 0, 0while p1 &lt; len(nums1) and p2 &lt; len(nums2):\tif condition1:\t\tp1 += 1\t\tp2 += 1\telif condition2:\t\tp1 += 1\telse:\t\tp2 += 1return something应用 sorted数组合并，求交集、并集问题" }, { "title": "二分查找 Binary Search（更新中）", "url": "/posts/Binary-Search/", "categories": "学习笔记", "tags": "Python, Algorithm", "date": "2022-05-14 19:00:00 -0500", "snippet": "前提条件 数组一定为有序数组！sorted array 数组不包含重复元素 unique/distinct values/elements步骤 target为目标数字, nums为数组名称 一般使用左闭右闭区间，即[left, right] define left = 0, right = len(nums) - 1 取中心节点mid位置，一般为mid = (left + rig...", "content": "前提条件 数组一定为有序数组！sorted array 数组不包含重复元素 unique/distinct values/elements步骤 target为目标数字, nums为数组名称 一般使用左闭右闭区间，即[left, right] define left = 0, right = len(nums) - 1 取中心节点mid位置，一般为mid = (left + right) // 2，或者在Java或者C++用left + (right - left) / 2防止int overflow 如果nums[mid]大于target，说明target存在于左区间，右节点right需等于mid - 1，在区间[left, mid - 1]里继续搜索 否则如果nums[mid]小于target，说明target存在于右区间，左节点left需等于mid + 1，在区间[mid + 1, right]里继续搜索 如果上述两种都不符合，则表示nums[mid]和target相等，直接return mid使用场景 寻找target元素下标 缩小存在target的范围（target可能不在这个数组里面）代码二分查找的代码可以有非递归和递归写法两种：非递归写法：class Solution: def search(self, nums: List[int], target: int) -&gt; int: left = 0 right = len(nums) - 1 # find target in [left, right] while left &lt;= right: # get the mid index mid = (left + right) // 2 if nums[mid] &gt; target: right = mid - 1 elif nums[mid] &lt; target: left = mid + 1 else: right = mid - 1 # return -1 if no target is find return -1递归写法：def binarySearch(array, left, right, target): if left &lt;= right: mid = left + (right - left) // 2 if array[mid] == target: return mid elif array[mid] &gt; target: return binarySearch(array, left, mid - 1, target) else: return binarySearch(array, mid + 1, right, target) else: return -1 binarySearch(nums, 0, len(nums) - 1, target)Leetcode 题目解释153. Find Minimum in Rotated Sorted Array这道题需要用左闭右开区间，因为位于mid的元素不能被排除，需要记录。因为是sorted array，任何时候如果nums[i] &lt;= nums[j]成立，说明从i到j区间一定是递增的。class Solution: def findMin(self, nums: List[int]) -&gt; int: left, right = 0, len(nums)-1 while left &lt; right: mid = left + (right - left) // 2 if nums[mid] &lt;= nums[right]: #如果这个条件成立，那么最小值要么是mid，要么在mid左侧，所以应该把right移过来 right = mid #搜索[left, mid)区间 else: left = mid + 1 return nums[left] #这个时候是刚好left = right，这边写nums[right]也是一样的33. Search in Rotated Sorted Array基本思路是正常二分，但是由于是旋转过的array，可能会出现两段递增区间。如果是只有一段区间（未旋转或者旋转次数恰好等于数组大小），则第二段区间默认为空数组。思路是先判断mid的位置，然后再进一步搜索target。class Solution: def search(self, nums: List[int], target: int) -&gt; int: left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid elif nums[mid] &gt;= nums[left]: # mid比left大，说明mid在左侧区间上，因为右侧区间的数字必然比左区间的都要小 if nums[left] &lt;= target &lt; nums[mid]: # target在左侧区间且比mid的值要小（左侧），移动right过来 right = mid - 1 else: # 除此之外，要么target在左侧但值比mid要大（右侧），要么是在右侧区间上，这些情况都是移动left过去 left = mid + 1 else: # 反之mid位于右侧区间 if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 return -134. Find First and Last Position of Element in Sorted Array因为有重复的元素，普通的二分查找需要进行一些改进，这边的方法是分别用二分法找左侧边界和右侧边界然后得出结果。会有几种情况： target out of bound，或者in bound但是不存在，则return [-1, -1] in bound且存在那就是return答案了class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: def findRight(nums, target): rightPos = -3 # 因为0会是答案的一种，初始化一个不可能的答案来判断 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right - left) // 2 if nums[mid] &lt;= target: # 找右侧边界的话，等于的情况要更新left left = mid + 1 rightPos = left else: right = mid - 1 return rightPos def findLeft(nums, target): leftPos = -3 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right - left) // 2 if nums[mid] &gt;= target: # 找左侧边界的话，等于的情况要更新right right = mid - 1 leftPos = right else: left = mid + 1 return leftPos # 这边上面找的左右边界都是在实际的边界之外一格的位置 leftPos = findLeft(nums, target) rightPos = findRight(nums, target) if leftPos == -3 or rightPos == -3: # out of bound 的情况，边界没有被更新 return [-1, -1] if rightPos - leftPos &gt; 1: # 是实际边界一格外的位置，所以差值至少为2 return [leftPos + 1, rightPos - 1] # 返回的时候把边界移到正确的位置 return[-1, -1] # 不存在的情况" }, { "title": "Python排序算法总结（更新中）", "url": "/posts/Python1/", "categories": "学习笔记", "tags": "Python, Algorithm", "date": "2022-05-14 18:09:00 -0500", "snippet": "1. 冒泡排序 Bobble Sort思路第i (i = 1, 2, 3, ...) 趟遍历的时候，从数列中前n - i + 1个元素的第1个开始，相邻两个元素进行比较，如果前一个比后一个大，则交换两个元素位置，否则不变。步骤 首先把第1个元素和第2个元素对比，如果满足条件则交换位置，然后比较第2个元素和第3个元素，以此类推，直到完成第n - 1个元素和第n个元素的比较。 第一步的结果导...", "content": "1. 冒泡排序 Bobble Sort思路第i (i = 1, 2, 3, ...) 趟遍历的时候，从数列中前n - i + 1个元素的第1个开始，相邻两个元素进行比较，如果前一个比后一个大，则交换两个元素位置，否则不变。步骤 首先把第1个元素和第2个元素对比，如果满足条件则交换位置，然后比较第2个元素和第3个元素，以此类推，直到完成第n - 1个元素和第n个元素的比较。 第一步的结果导致整个数组中最大的元素处在数组第n个的位置上。 然后对前n - 1个元素执行同样操作，导致前n - 1个元素中最大的元素处在数组第n - 1的位置上。 然后对前n - 2个元素执行同样操作，直到某一次遍历没有任何交换操作发生为止结束排序。复杂度和使用场景 Best case: ascending order array, 只需要经过n - 1次比较即可完成排序，time complexity = O(n) Worst case: decending order array或者最小值在数组末尾，需要经过0.5 * n * (n - 1)次比较完成排序，time complexity = O(n^2) 没有创造新数组，space complexity = O(1) 移动次数多，适合较小数组，最好初始状态基本有序 一般情况排序时间最长，效率最低 不改变相同元素相对位置，属于稳定排序法代码def bubble_sort(array): for i in range(len(array)): for j in range(len(array) - i - 1): # skip sorted elements # compare adjacent values if array[j] &gt; array[j+1]: array[j], array[j+1] = array[j+1], array[j] # Python不需要temp return array2. 选择排序 Selection Sort思路每一次遍历时，将未排序元素中最小的元素与未排序元素中第一个元素交换位置，直到遍历整个数组。步骤 define int i， 代表遍历次数，以及该遍历次数参加排序元素的第一个元素的下标 define minvalue = i， 代表参加排序元素里面最小的元素的下标，初始值定为第一个 把参加排序的元素对array[minvalue]进行比较，如果比array[minvalue]小则交换位置复杂度和使用场景 无论数组构成如何，都需要经过0.5 * n * (n - 1)次元素之间的比较完成排序，time complexity = O(n^2) 没有创造新数组，space complexity = O(1) 有交换不相邻元素，可能改变了相同元素相对位置，属于不稳定排序法代码def bubble_sort(array): for i in range(len(array) - 1): minvalue = i for j in range(i + 1, len(array)): # update minvalue if array[j] &lt; array[minvalue]: minvalue = j # swap if minvalue changed if minvalue != i: array[i], array[minvalue] = array[minvalue], array[i] return array3. 插入排序 Insertion Sort思路划分整个数组为无序数组和有序数组，每一次遍历时，将无序数组的第一个元素插入到有序数组合适的位置，直到遍历整个数组。步骤 需要定义一个temp来存储待插入的元素 选择数组第1个元素为有序数组， 剩下2 ~ (n - 1)个为无序数组 遍历整个数组，把无序数组的第一个元素插入到有序数组合适的位置 重复遍历操作复杂度和使用场景 Best case: ascending order array, 只需要经过n - 1次比较即可完成排序，time complexity = O(n) Worst case: decending order array，需要经过0.5 * n * (n - 1)次比较完成排序，time complexity = O(n^2) 没有创造新数组，space complexity = O(1) 属于稳定排序法代码def insertion_sort(array): for i in range(1, len(array)): temp = array[i] j = i while j &gt; 0 and array[j - 1] &gt; temp: # 比temp大的元素向后移动位置 # 向后移动 array[j + 1] = array[j] # 继续找前一个 j -= 1 array[j + 1] = temp # 插入这个元素 return array4. 希尔排序 Shell Sort思路" } ]
